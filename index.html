<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Example</title>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
            "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/",
            "@pixiv/three-vrm": "/lib/three-vrm.module.js"
        }
      }
    </script>

    <style>
        body {
            margin: 0;
            display: flex;
            height: 100vh;
            background-image: url("img/bg.jpg");
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: flex;
            justify-content: center;
            align-items: center;
            align-content: space-around;
        }

        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        /* Comment Box */
        #comment-box {
            width: 40%; /* Adjust the width as needed */
            height: 70%; /* Adjust the height as needed */
            background-color: rgba(0, 0, 0, 0.8); /* Dark background with transparency */
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Roboto', sans-serif;
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* Subtle shadow for depth */
            position: relative; /* Ensure positioning is relative to the container */
        }

        /* Header Inside the Comment Box */
        #comment-header {
            width: 100%;
            padding: 15px;
            font-size: 24px;
            font-family: 'Noto Sans JP', sans-serif;
            font-weight: bold;
            text-align: center;
            background: linear-gradient(45deg, #ff89a6, #ff005a); /* Gradient background */
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px; /* Space between header and the decorative section */
        }

        /* Decorative Section Above the Line */
        #decorative-section {
            width: 100%;
            height: 60px; /* Adjust the height for visual impact */
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.3)), url('path/to/decorative-pattern.png'); /* Pattern and gradient background */
            background-size: cover;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
        }

        /* Text in Decorative Section */
        #decorative-text {
            font-size: 18px;
            color: #ffd700; /* Gold color */
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5); /* Text shadow for better readability */
            font-weight: bold;
        }

        /* Extra Creative Element Section */
        #extra-creative {
            width: 100%;
            height: 80px; /* Adjust as needed */
            background: rgba(255, 255, 255, 0.2); /* Semi-transparent background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            position: relative;
        }

        /* Content for the Extra Creative Section */
        #extra-creative-content {
            font-size: 20px;
            color: #ffeb3b; /* Bright yellow */
            text-align: center;
            line-height: 1.4;
            font-weight: bold;
        }

        /* Artistic Horizontal Line */
        #horizontal-line {
            width: 100%;
            height: 2px;
            background: linear-gradient(to right, transparent, #ffffff, transparent);
            margin: 20px 0; /* Space around the line */
            position: absolute;
            top: 45%; /* Position at the middle of the comment box */
            left: 0;
            transform: translateY(-50%); /* Center the line vertically */
        }

        /* Live Comments Section Below the Line */
        #comment-content {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Spacing between comments */
            overflow-y: auto; /* Scrollable */
            padding-top: 60px; /* Space for the comments to be visible */
            padding-bottom: 10px; /* Space for the bottom text */
            position: absolute;
            top: 43%; /* Start below the horizontal line */
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            box-sizing: border-box;
        }

        /* Each Comment Block */
        .comment {
            display: flex;
            flex-direction: column;
            padding: 8px 10px;
            background-color: rgba(255, 255, 255, 0.1); /* Semi-transparent white for comments */
            border-radius: 5px;
            animation: fade-in 0.5s ease-in-out;
            font-size: 14px;
            overflow: hidden; /* Hide overflow */
            font-family: 'Arial', sans-serif;
        }

        /* Username Styling */
        .comment .username {
            font-weight: bold;
            font-size: 15px;
            color: #ffd700; /* Gold color for the username */
        }

        /* Comment Text Styling */
        .comment .message {
            font-size: 14px;
            color: #ffffff;
            margin-top: 2px;
        }

        /* Smooth Fade-in Animation for New Comments */
        @keyframes fade-in {
            0% {
                opacity: 0;
                transform: translateY(10px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }





        #right-side {
            width: 50%; /* Takes up more space now */
            height: 100vh; /* Full height */
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
    </style>
</head>

<body>

    <div id="comment-box">
        <!-- Header Inside the Comment Box -->
        <div id="comment-header">Live Chat ‚Ä¢ Igarashi Stream</div>
    
        <!-- Decorative Section Above the Line -->
        <div id="decorative-section">
            <div id="decorative-text">Welcome to the Stream!</div>
        </div>
    
        <!-- Extra Creative Element Section -->
        <div id="extra-creative">
            <div id="extra-creative-content">
                üéâ Enjoy the Show! üéä<br>
                „Åì„Åì„ÅßÁõõ„Çä‰∏ä„Åå„Çç„ÅÜÔºÅ<br> <!-- Japanese Text for Excitement -->
                Comments from the user! üí¨
            </div>
        </div>

        <!-- Artistic Horizontal Line in the Middle -->
        <div id="horizontal-line"></div>
    
        <!-- Comment Content Below the Line -->
        <div id="comment-content"></div>
    </div>
    

    
    <div id="right-side">
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';
        import { VRMLoaderPlugin, VRMUtils, VRM, VRMExpression, VRMExpressionMorphTargetBind  } from '@pixiv/three-vrm';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        let mixer = null;
        let joinSpringManager = null;
        let currentVrm = undefined;
        let animationClip;
        let mapAction = new Map();
        let currentBvhFilePath = '';

        const imageFile = new Map();
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10);
        camera.position.set(0, 1.5, -1.0); // Adjusted to focus on the upper body
        camera.rotation.set(0, Math.PI, 0);

        let now = new Date(new Date().toUTCString());

        const rightSide = document.getElementById('right-side');
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(rightSide.clientWidth, rightSide.clientHeight);
        rightSide.appendChild(renderer.domElement);

        window.addEventListener('resize', () => {
            renderer.setSize(rightSide.clientWidth, rightSide.clientHeight);
        });



        const targetAspect = document.body.clientWidth / document.body.clientHeight;

        const light = new THREE.DirectionalLight(0xffffff);
        light.position.set(-1, 1, -1).normalize();
        scene.add(light);

        const canvas = document.createElement('canvas');
        // canvas.width = 400; // Adjust size as needed
        // canvas.height = 512; // Adjust size as needed
        const context = canvas.getContext('2d');

        const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#ff6f61'); // Start color (coral)
        gradient.addColorStop(1, '#ffb74d'); // End color (orange)

        const commentBox = document.getElementById('comment-content');
        const maxVisibleComments = 6; // Maximum number of visible comments
        // Remove the redeclaration of the variable
        


        function addCommentToBox(commentText) {
            const comment = document.createElement('div');
            comment.className = 'comment';
            comment.textContent = commentText;
    
            // Add the new comment at the end
            commentBox.appendChild(comment);
    
            // Remove the oldest comment if the total exceeds maxVisibleComments
            const comments = commentBox.querySelectorAll('.comment');
            if (comments.length > maxVisibleComments) {
                commentBox.removeChild(comments[0]); // Remove the oldest comment (first in the list)
            }
        }
    
        // Initialize EventSource for real-time comments
        function initializeCommentStream() {
            const eventSource = new EventSource('http://localhost:8000/stream-comments-only');

            eventSource.onmessage = function(event) {
                try {
                    // Replace single quotes with double quotes to handle JSON format
                    let formattedData = event.data.replace(/'/g, '"');

                    // Parse the JSON data
                    const commentData = JSON.parse(formattedData);

                    // Extract author and message
                    const author = commentData.author || 'Anonymous';
                    const message = commentData.message || '';

                    // Add formatted comment to the box
                    addCommentToBox(`${author}: ${message}`);
                    
                } catch (error) {
                    console.error('Error processing comment data:', error);
                }
            };

            eventSource.onerror = function(event) {
                console.error('Error occurred:', event);
                eventSource.close();
            };
        }

    
        initializeCommentStream();


        // // Initialize the EventSource to receive the stream of comments
        // const eventSource = new EventSource('http://localhost:8000/stream-comments');

        // // Listen for incoming events
        // eventSource.onmessage = function(event) {
        //     const comment = event.data;
        //     console.log('Received comment from /stream-comments:', comment);

        //     // Play the generated audio once a new comment is received
        //     playAudio();
        // };

        // // Function to play the audio file (e.g., "speech_output.wav")
        // function playAudio() {
        //     // 1. Create an AudioListener and add it to the camera
        //     const listener = new THREE.AudioListener();
        //     camera.add(listener);

        //     // 2. Create a global audio source
        //     const sound = new THREE.Audio(listener);

        //     // 3. Load the sound file using AudioLoader
        //     const audioLoader = new THREE.AudioLoader();
        //     audioLoader.load('speech_output.wav', function(buffer) {
        //         sound.setBuffer(buffer);
        //         sound.setLoop(false); // Play the audio only once
        //         sound.setVolume(0.5);
        //         sound.play();

        //         // Handle what happens after the audio finishes playing
        //         sound.onEnded = function() {
        //             console.log('Audio finished playing.');
        //         };
        //     }, function(xhr) {
        //         console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        //     }, function(error) {
        //         console.error('An error occurred loading the audio:', error);
        //     });
        // }

        // Handle errors from the SSE stream
        // eventSource.onerror = function(event) {
        //     console.error('Error in SSE stream:', event);
        // };



        loadVrm();
        function loadVrm() {

            const loader = new GLTFLoader();

            loader.register((parser) => {
                return new VRMLoaderPlugin(parser);
            });

            loader.load(
                `/models/Sena_Saotome.vrm`,
                (gltf) => {
                    const vrm = gltf.userData.vrm;
                    VRMUtils.removeUnnecessaryVertices(gltf.scene);
                    VRMUtils.removeUnnecessaryJoints(gltf.scene);
                    vrm.scene.traverse((obj) => {
                        obj.frustumCulled = false;
                    });
                    scene.add(vrm.scene);
                    currentVrm = vrm;

                    vrm.scene.position.set(0.5, -1.1, 1);
                    vrm.scene.rotation.y = 0;
                    vrm.scene.scale.set(2.3, 2, 2.3);

                    joinSpringManager = vrm.springBoneManager;

                    if (currentVrm) {
                        applyAnimation('/bvh/talking1.bvh', 'waiting');
                    }
                    setTimeout(() => {
                        console.log('success');
                    }, 3000);
                },
                (progress) => { },
                (error) => console.error(error)
            );
        }

        let isProcessed = true;
        let lastTimeUpdateMotion = 0;

        let isFading = false;
        let loading = false;
        let currentAction;
        let pendingAnimation = null;

        function applyAnimation(bvhFilePath, animationName ) {      
            if (!currentVrm) return; // VRM„Åå„É≠„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„Å™„Åë„Çå„Å∞‰Ωï„ÇÇ„Åó„Å™„ÅÑ
            currentVrm.lastTimeUpdateMotion = 0;
            currentVrm.loading = false;
            currentVrm.isFading = false;
            currentVrm.currentAction = null;
            currentVrm.pendingAnimation = null;
            if (currentVrm.currentBvhFilePath === bvhFilePath) return;
            console.log(currentVrm.currentBvhFilePath);
            if (mapAction.get(bvhFilePath)) {
                console.log('haveFile');
                if (!mixer) {
                    mixer = new THREE.AnimationMixer(currentVrm.scene);
                    currentVrm.mixer = mixer;
                }
                if (currentVrm.isFading || currentVrm.loading) {

                    currentVrm.pendingAnimation = bvhFilePath;
                    return;
                }
                synchronizeCrossFade(bvhFilePath, 1, currentVrm);
            } else {
                console.log('Dont`t haveFile');

                currentVrm.loading = true;
                const loader1 = new BVHLoader();
                loader1.load(bvhFilePath, function (result) {
                    for (let i = result.clip.tracks.length; i--;) {
                        let track = result.clip.tracks[i];
                        var value = [];
                        var extension = track.name.split('.').pop();
                        let map = new Map(Object.entries(currentVrm.humanoid.humanBones));
                        var exists = Array.from(map.keys()).find(obj => { 
                            return track.name.toLowerCase().includes(obj.toLowerCase())});
                        if(exists){
                            if(extension){
                                track.name = `${map.get(exists).node.name}.${extension}`
                            } else {
                                track.name = `${map.get(exists).node.name}`
                            }
                        };
                        if (track.name.toLowerCase().match(/.+\.([^?]+)(\?|$)/)[1] === "position") {
                            if ([].includes(track.name)) {
                                continue;
                            } else {
                                result.clip.tracks.splice(i, 1);
                            }
                        } else {
                            if ([].includes(track.name)) {
                                result.clip.tracks.splice(i, 1);
                            } else {
                                for (var trackValue of track.values) {
                                    var trackValueNew = trackValue;
                                    if (track.values.indexOf(trackValue) % 4 == 3) {
                                        trackValueNew = -trackValue;
                                    }
                                    if (track.values.indexOf(trackValue) % 4 == 1) {
                                        trackValueNew = -trackValue;
                                    }
                                    value.push(trackValueNew);
                                }
                            }
                            track.values = value;
                            track.values.splice(0, 4);
                            track.times = track.times.subarray(1);
                        }
                    }
                    if (!mixer) {
                        mixer = new THREE.AnimationMixer(currentVrm.scene);
                        currentVrm.mixer = mixer;
                    }
                    currentVrm.animationClip = result.clip;
                    currentVrm.animationClip.name = bvhFilePath;
                    currentVrm.animationClip.duration = calculateDuration(result.clip);
                    console.log('duration', currentVrm.animationClip.duration);

                    currentVrm.loading = false;
                    if (currentVrm.isFading || currentVrm.loading) {

                        currentVrm.pendingAnimation = bvhFilePath;
                        return;
                    }
                    mapAction.set(bvhFilePath, currentVrm.animationClip);

                    synchronizeCrossFade(bvhFilePath, 1, currentVrm);
                });
            }
            currentVrm.currentBvhFilePath = bvhFilePath;
        }

        function getIndex(nameKey){
            var index = -1;
            currentVrm.scene.traverse((obj) => {
                if(index >= 0) return;
                if(obj.isMesh && obj.name.toLowerCase().includes('face')){
                    console.log(obj.geometry.userData['targetNames']);
                    if(obj.geometry.userData['targetNames']){
                        var thisIndex = obj.geometry.userData['targetNames'].indexOf(nameKey)
                        console.log(thisIndex);
                        index = thisIndex;
                    }
                }
            });
            return index;
        }

        function synchronizeCrossFade(bvhFilePath, duration) {
            var currentDate = new Date().getTime();
            if ((currentDate - lastTimeUpdateMotion) < 1000) {
                return;
            }
            lastTimeUpdateMotion = currentDate;
            console.log(new Date().toISOString());
            const loadAndApply = (clip) => {
                if (currentAction) {
                    currentAction.fadeOut(duration);
                    isFading = true;
                    console.log(duration * 1000);
                    setTimeout(() => {
                        console.log('pendingAnimation');
                        isFading = false;
                        if (pendingAnimation) {
                            applyAnimation(
                                pendingAnimation,
                                pendingAnimation.animationName
                            );
                            pendingAnimation = null;
                        }
                    }, duration * 1000);
                }

                const newAction = mixer.clipAction(clip);
                newAction.setLoop(THREE.LoopRepeat);
                newAction.clampWhenFinished = false;
                console.log('playEndAction', new Date());
                newAction.reset();
                newAction.fadeIn(duration);
                newAction.play();

                currentAction = newAction;
            };

            if (mapAction.has(bvhFilePath)) {
                loadAndApply(mapAction.get(bvhFilePath));
            }
        }

        function isSameType(pendingAnimation) {
            var pendingNotNumber = pendingAnimation.replace(/[0-9]/g, '').replace('.bvh', '');
            var currentNotNumber = currentBvhFilePath.replace(/[0-9]/g, '').replace('.bvh', '');
            console.log(pendingNotNumber === currentNotNumber);
            return pendingNotNumber === currentNotNumber;
        }

        function calculateDuration(bvhClip) {
            const frames = bvhClip.tracks[0].times.length;
            const frameTime = bvhClip.tracks[0].times[1] - bvhClip.tracks[0].times[0];
            return frames * frameTime;
        }

        animate();
        function animate() {

            setTimeout(() => {
                animate();
            }, 0.02 * 1000)

            renderer.render(scene, camera);

            if (mixer) mixer.update(0.02 );

            if (joinSpringManager) joinSpringManager.update(10 / 1000);

            if (currentVrm && currentVrm.expressionManager) {
                currentVrm.expressionManager.update();
            }

        }
    
    </script>
    <script>
        // const commentBox = document.getElementById('comment-content');
        // const maxVisibleComments = 6; // Maximum number of visible comments


        // function addCommentToBox(commentText) {
        //     const comment = document.createElement('div');
        //     comment.className = 'comment';
        //     comment.textContent = commentText;
    
        //     // Add the new comment at the end
        //     commentBox.appendChild(comment);
    
        //     // Remove the oldest comment if the total exceeds maxVisibleComments
        //     const comments = commentBox.querySelectorAll('.comment');
        //     if (comments.length > maxVisibleComments) {
        //         commentBox.removeChild(comments[0]); // Remove the oldest comment (first in the list)
        //     }
        // }
    
        // // Initialize EventSource for real-time comments
        // function initializeCommentStream() {
        //     const eventSource = new EventSource('http://localhost:8000/stream-comments-only');

        //     eventSource.onmessage = function(event) {
        //         try {
        //             // Replace single quotes with double quotes to handle JSON format
        //             let formattedData = event.data.replace(/'/g, '"');

        //             // Parse the JSON data
        //             const commentData = JSON.parse(formattedData);

        //             // Extract author and message
        //             const author = commentData.author || 'Anonymous';
        //             const message = commentData.message || '';

        //             // Add formatted comment to the box
        //             addCommentToBox(`${author}: ${message}`);
        //         } catch (error) {
        //             console.error('Error processing comment data:', error);
        //         }
        //     };

        //     eventSource.onerror = function(event) {
        //         console.error('Error occurred:', event);
        //         eventSource.close();
        //     };
        // }

    
        // initializeCommentStream();
    </script>
    
</body>

</html>