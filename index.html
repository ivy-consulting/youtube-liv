<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Example</title>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
            "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/",
            "@pixiv/three-vrm": "/lib/three-vrm.module.js"
        }
      }
    </script>
</head>

<body>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';
        import { VRMLoaderPlugin, VRMUtils, VRM, VRMExpression, VRMExpressionMorphTargetBind  } from '@pixiv/three-vrm';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';


        

        let mixer = null;
        let joinSpringManager = null;
        let currentVrm = undefined;
        let animationClip;
        // let clock = new THREE.Clock();
        let mapAction = new Map();
        let currentBvhFilePath = '';

        
        // const mapBVHFile = new Map();
        const imageFile = new Map();
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10);
        camera.position.set(0, 1.5, -1.0); // Adjusted to focus on the upper bod
        // camera.position.set(0, 1.3, -1.45);
        camera.rotation.set(0, Math.PI, 0);

        let now = new Date(new Date().toUTCString());

        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const targetAspect = document.body.clientWidth / document.body.clientHeight;


        const light = new THREE.DirectionalLight(0xffffff);
        light.position.set(-1, 1, -1).normalize();
        scene.add(light);
        // scene.background = new THREE.Color(0x202020); // Set a background color

        const imgLoader = new THREE.TextureLoader();
        imgLoader.load('img/bg.jpg', function(texture){
            scene.background = texture;
        });

        // Create the rectangle geometry with desired width and height
        const rectWidth = 2;  // Width of the rectangle
        const rectHeight = 2; // Height of the rectangle
        const rectGeometry = new THREE.PlaneGeometry(rectWidth, rectHeight);

        // Create a canvas for the gradient background
        const canvas = document.createElement('canvas');
        canvas.width = 512; // Adjust size as needed
        canvas.height = 512; // Adjust size as needed
        const context = canvas.getContext('2d');

        // Create a gradient
        const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#ff6f61'); // Start color (coral)
        gradient.addColorStop(1, '#ffb74d'); // End color (orange)

        // Fill the canvas with the gradient
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);

        // Create a texture from the canvas
        const texture = new THREE.CanvasTexture(canvas);

        // Create a material with the texture and set transparency
        const gradientMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide, // Render both sides of the plane
            transparent: true, // Enable transparency
            opacity: 0.8 // Set opacity to make the rectangle slightly transparent
        });

        // Create the rectangle mesh with gradient material
        const rectMesh = new THREE.Mesh(rectGeometry, gradientMaterial);

        // Create a parent group to hold the rectangle
        const rectGroup = new THREE.Group();
        rectGroup.add(rectMesh);

        // Position the rectangle
        rectGroup.position.set(1, 1.5, 3); // Adjust the position as needed

        // Add the group to the scene
        scene.add(rectGroup);








        

        const fontLoader = new FontLoader();

        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            const textGeometry = new TextGeometry('Helo', {
                font: font,
                size: 0.06, // Adjust the size of the text
                height: 0.003, // Reduce the thickness of the text
                curveSegments: 12, // Smoothness of the curves
                bevelEnabled: true,
                bevelThickness: 0.00003, // Reduce the thickness of the bevel
                bevelSize: 0.0001,
                bevelOffset: 0,
                bevelSegments: 3
            });

            const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Change the color here
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);

            textMesh.position.set(1.2, 2, 1.5); // Adjust these values as needed
            textMesh.rotation.y = Math.PI; // Rotate around the X-axis by 180 degrees

            scene.add(textMesh);
        });


     


        loadVrm();
        function loadVrm() {

            const loader = new GLTFLoader();

            // Install GLTFLoader plugin
            loader.register((parser) => {
                return new VRMLoaderPlugin(parser);
            });

            loader.load(
                `/models/Sena_Saotome.vrm`,
                // `/models/aichan.vrm`,

                // called when the resource is loaded
                (gltf) => {
                    const vrm = gltf.userData.vrm;
                    // calling these functions greatly improves the performance
                    VRMUtils.removeUnnecessaryVertices(gltf.scene);
                    VRMUtils.removeUnnecessaryJoints(gltf.scene);
                    // Disable frustum culling
                    vrm.scene.traverse((obj) => {
                        obj.frustumCulled = false;
                    });
                    scene.add(vrm.scene);
                    currentVrm = vrm;

                    vrm.scene.position.set(-0.8, -0.2, 1); // Lower the model further on the Y-axis to focus even more on the upper body
                    vrm.scene.rotation.y = - Math.PI / 6;
                    vrm.scene.scale.set(1.5, 1.5, 1.5); // Maintain the zoom level
                    


                    console.log(currentVrm.humanoid.humanBones);
                    joinSpringManager = vrm.springBoneManager;
                    console.log(joinSpringManager);
                    console.log(currentVrm);

                    var listSkinFaceMesh = [];

                    currentVrm.expressionManager.setValue("test", 1);
                    if (currentVrm) {
                        applyAnimation('/bvh/talking1.bvh', 'waiting');
                    }
                    setTimeout(() => {
                        console.log('success');
                    }, 3000);
                },

                // called while loading is progressing
                (progress) => { },

                // called when loading has errors
                (error) => console.error(error),
            );
        }

        let isProcessed = true;
        let lastTimeUpdateMotion = 0;

        let isFading = false;
        let loading = false;
        let currentAction;
        let pendingAnimation = null;


        function applyAnimation(bvhFilePath, animationName ) {      
            if (!currentVrm) return; // VRMがロードされていなければ何もしない
            currentVrm.lastTimeUpdateMotion = 0;
            currentVrm.loading = false;
            currentVrm.isFading = false;
            currentVrm.currentAction = null;
            currentVrm.pendingAnimation = null;
            // var mixer = currentVrm.mixer;
            if (currentVrm.currentBvhFilePath === bvhFilePath) return;
            console.log(currentVrm.currentBvhFilePath);
            if (mapAction.get(bvhFilePath)) {
                console.log('haveFile');
                if (!mixer) {
                    mixer = new THREE.AnimationMixer(currentVrm.scene);
                    currentVrm.mixer = mixer;
                }
                // const startAction = mapAction.get(currentBvhFilePath)
                // const endAction = mapAction.get(bvhFilePath);
                if (currentVrm.isFading || currentVrm.loading) {

                    currentVrm.pendingAnimation = bvhFilePath;
                    return;
                }
                synchronizeCrossFade(bvhFilePath, 1, currentVrm);
            } else {
                console.log('Dont`t haveFile');

                currentVrm.loading = true;
                const loader1 = new BVHLoader();
                loader1.load(bvhFilePath, function (result) {
                    for (let i = result.clip.tracks.length; i--;) {
                        let track = result.clip.tracks[i];
                        var value = [];
                        var extension = track.name.split('.').pop();
                        // console.log(track.name);
                        // console.log(extension);
                        let map = new Map(Object.entries(currentVrm.humanoid.humanBones));
                        var exists = Array.from(map.keys()).find(obj => { 
                            return track.name.toLowerCase().includes(obj.toLowerCase())});
                        if(exists){
                            if(extension){
                                track.name = `${map.get(exists).node.name}.${extension}`
                            } else {
                                track.name = `${map.get(exists).node.name}`
                            }
                        };
                        if (track.name.toLowerCase().match(/.+\.([^?]+)(\?|$)/)[1] === "position") {
                            if ([].includes(track.name)) {
                                continue;
                            } else {
                                result.clip.tracks.splice(i, 1);
                            }
                        } else {
                            if ([].includes(track.name)) {
                                result.clip.tracks.splice(i, 1);
                            } else {
                                for (var trackValue of track.values) {
                                    var trackValueNew = trackValue;
                                    if (track.values.indexOf(trackValue) % 4 == 3) {
                                        trackValueNew = -trackValue;
                                    }
                                    if (track.values.indexOf(trackValue) % 4 == 1) {
                                        trackValueNew = -trackValue;
                                    }
                                    value.push(trackValueNew);
                                }
                            }
                            track.values = value;
                            track.values.splice(0, 4);
                            track.times = track.times.subarray(1);
                        }
                    }
                    // console.log(result.clip);
                    // console.log(value.map((e)=> e.name));
                    // AnimationMixerの生成
                    if (!mixer) {
                        mixer = new THREE.AnimationMixer(currentVrm.scene);
                        currentVrm.mixer = mixer;
                    }
                    currentVrm.animationClip = result.clip;
                    currentVrm.animationClip.name = bvhFilePath;
                    currentVrm.animationClip.duration = calculateDuration(result.clip);
                    console.log('duration', currentVrm.animationClip.duration);
                   
                    currentVrm.loading = false;
                    if (currentVrm.isFading || currentVrm.loading) {

                        currentVrm.pendingAnimation = bvhFilePath;
                        return;
                    }
                    mapAction.set(bvhFilePath, currentVrm.animationClip);

                    synchronizeCrossFade(bvhFilePath, 1, currentVrm);
                  
                });
            }
            currentVrm.currentBvhFilePath = bvhFilePath;
        }

        function getIndex(nameKey){
            var index = -1;
            currentVrm.scene.traverse((obj) => {
                if(index >= 0) return;
                if(obj.isMesh && obj.name.toLowerCase().includes('face')){
                    console.log(obj.geometry.userData['targetNames']);
                    if(obj.geometry.userData['targetNames']){
                        var thisIndex = obj.geometry.userData['targetNames'].indexOf(nameKey)
                        console.log(thisIndex);
                        index = thisIndex;
                    }
                }
            });
            return index;
        }


        function synchronizeCrossFade(bvhFilePath, duration) {
            var currentDate = new Date().getTime();
            if ((currentDate - lastTimeUpdateMotion) < 1000) {
                return;
            }
            lastTimeUpdateMotion = currentDate;
            console.log(new Date().toISOString());
            // console.log("startAction", startAction);
            const loadAndApply = (clip) => {
                if (currentAction) {
                    currentAction.fadeOut(duration);
                    isFading = true;
                    console.log(duration * 1000);
                    setTimeout(() => {
                        console.log('pendingAnimation');
                        isFading = false;
                        if (pendingAnimation) {
                            applyAnimation(
                                pendingAnimation,
                                pendingAnimation.animationName
                            );
                            pendingAnimation = null;
                        }
                    }, duration * 1000);
                }

                const newAction = mixer.clipAction(clip);
                newAction.setLoop(THREE.LoopRepeat);
                newAction.clampWhenFinished = false;
                console.log('playEndAction', new Date());
                newAction.reset();
                newAction.fadeIn(duration);
                newAction.play();

                currentAction = newAction;
            };

            if (mapAction.has(bvhFilePath)) {
                loadAndApply(mapAction.get(bvhFilePath));
            }

        }

        function isSameType(pendingAnimation) {
            var pendingNotNumber = pendingAnimation.replace(/[0-9]/g, '').replace('.bvh', '');
            var currentNotNumber = currentBvhFilePath.replace(/[0-9]/g, '').replace('.bvh', '');
            console.log(pendingNotNumber === currentNotNumber);
            return pendingNotNumber === currentNotNumber;
        }

        function calculateDuration(bvhClip) {
            const frames = bvhClip.tracks[0].times.length;
            const frameTime = bvhClip.tracks[0].times[1] - bvhClip.tracks[0].times[0];
            return frames * frameTime;
        }

        animate();
        function animate() {


            setTimeout(() => {
                animate();
            }, 0.02 * 1000)

            renderer.render(scene, camera);

            if (mixer) mixer.update(0.02 );

            if (joinSpringManager) joinSpringManager.update(10 / 1000);

            if (currentVrm && currentVrm.expressionManager) {
                currentVrm.expressionManager.update();
            }


        }
    </script>
    <script>

    </script>
</body>

</html>